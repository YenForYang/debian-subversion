<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Subversion: svn_delta_editor_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="svn-square.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Subversion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">svn_delta_editor_t Struct Reference<div class="ingroups"><a class="el" href="group__delta__support.html">Delta generation and handling</a> &raquo; <a class="el" href="group__svn__delta__tree__deltas.html">Tree deltas</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A structure full of callback functions the delta source will invoke as it produces the delta.  
 <a href="structsvn__delta__editor__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a34125322c4f485687f0b0a2ccaea84db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a34125322c4f485687f0b0a2ccaea84db">set_target_revision</a> )(void *edit_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> target_revision, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a34125322c4f485687f0b0a2ccaea84db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target revision for this edit to <em>target_revision</em>.  <a href="#a34125322c4f485687f0b0a2ccaea84db">More...</a><br /></td></tr>
<tr class="separator:a34125322c4f485687f0b0a2ccaea84db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7fa0f1296811edaa3808a1cb630a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#afc7fa0f1296811edaa3808a1cb630a45">open_root</a> )(void *edit_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *result_pool, void **root_baton)</td></tr>
<tr class="memdesc:afc7fa0f1296811edaa3808a1cb630a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>*root_baton</em> to a baton for the top directory of the change.  <a href="#afc7fa0f1296811edaa3808a1cb630a45">More...</a><br /></td></tr>
<tr class="separator:afc7fa0f1296811edaa3808a1cb630a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cac42610758f4b2c20f4e37ae613db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a2cac42610758f4b2c20f4e37ae613db4">delete_entry</a> )(const char *path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, void *parent_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a2cac42610758f4b2c20f4e37ae613db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the directory entry at <em>path</em>, a child of the directory represented by <em>parent_baton</em>.  <a href="#a2cac42610758f4b2c20f4e37ae613db4">More...</a><br /></td></tr>
<tr class="separator:a2cac42610758f4b2c20f4e37ae613db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c63bef6b9de90802287a3c2697138d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#ae9c63bef6b9de90802287a3c2697138d">add_directory</a> )(const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *result_pool, void **child_baton)</td></tr>
<tr class="memdesc:ae9c63bef6b9de90802287a3c2697138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are going to add a new subdirectory at <em>path</em>, a child of the directory represented by <em>parent_baton</em>.  <a href="#ae9c63bef6b9de90802287a3c2697138d">More...</a><br /></td></tr>
<tr class="separator:ae9c63bef6b9de90802287a3c2697138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4b50102b318e593e206b18a95584e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a4e4b50102b318e593e206b18a95584e5">open_directory</a> )(const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *result_pool, void **child_baton)</td></tr>
<tr class="memdesc:a4e4b50102b318e593e206b18a95584e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are going to make changes in the subdirectory at <em>path</em>, a child of the directory represented by <em>parent_baton</em>.  <a href="#a4e4b50102b318e593e206b18a95584e5">More...</a><br /></td></tr>
<tr class="separator:a4e4b50102b318e593e206b18a95584e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197108c566d919c1c7528e213f983f95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a197108c566d919c1c7528e213f983f95">change_dir_prop</a> )(void *dir_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a197108c566d919c1c7528e213f983f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of a directory's property.  <a href="#a197108c566d919c1c7528e213f983f95">More...</a><br /></td></tr>
<tr class="separator:a197108c566d919c1c7528e213f983f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10ab4a3452a9d3cbcb852392c87238b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#ad10ab4a3452a9d3cbcb852392c87238b">close_directory</a> )(void *dir_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ad10ab4a3452a9d3cbcb852392c87238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are done processing a subdirectory, whose baton is <em>dir_baton</em> (set by <code>add_directory</code> or <code>open_directory</code>).  <a href="#ad10ab4a3452a9d3cbcb852392c87238b">More...</a><br /></td></tr>
<tr class="separator:ad10ab4a3452a9d3cbcb852392c87238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa426a6ce836356fd058e31ec942a26f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#aa426a6ce836356fd058e31ec942a26f5">absent_directory</a> )(const char *path, void *parent_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:aa426a6ce836356fd058e31ec942a26f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the directory represented by <em>parent_baton</em>, indicate that <em>path</em> is present as a subdirectory in the edit source, but cannot be conveyed to the edit consumer.  <a href="#aa426a6ce836356fd058e31ec942a26f5">More...</a><br /></td></tr>
<tr class="separator:aa426a6ce836356fd058e31ec942a26f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76e7e2f8a4ac090de385e08d96e3139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#aa76e7e2f8a4ac090de385e08d96e3139">add_file</a> )(const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *result_pool, void **file_baton)</td></tr>
<tr class="memdesc:aa76e7e2f8a4ac090de385e08d96e3139"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are going to add a new file at <em>path</em>, a child of the directory represented by <em>parent_baton</em>.  <a href="#aa76e7e2f8a4ac090de385e08d96e3139">More...</a><br /></td></tr>
<tr class="separator:aa76e7e2f8a4ac090de385e08d96e3139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00452a0fc66e4f65244ce74d2af8d6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a00452a0fc66e4f65244ce74d2af8d6b8">open_file</a> )(const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *result_pool, void **file_baton)</td></tr>
<tr class="memdesc:a00452a0fc66e4f65244ce74d2af8d6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are going to make changes to a file at <em>path</em>, a child of the directory represented by <em>parent_baton</em>.  <a href="#a00452a0fc66e4f65244ce74d2af8d6b8">More...</a><br /></td></tr>
<tr class="separator:a00452a0fc66e4f65244ce74d2af8d6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe224723d88caa5d8e8a2575e72e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a05fe224723d88caa5d8e8a2575e72e04">apply_textdelta</a> )(void *file_baton, const char *base_checksum, apr_pool_t *result_pool, <a class="el" href="group__svn__delta__txt__delta.html#ga4ca253c7fddd39261d28e76ba9c959f4">svn_txdelta_window_handler_t</a> *handler, void **handler_baton)</td></tr>
<tr class="memdesc:a05fe224723d88caa5d8e8a2575e72e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a text delta, yielding the new revision of a file.  <a href="#a05fe224723d88caa5d8e8a2575e72e04">More...</a><br /></td></tr>
<tr class="separator:a05fe224723d88caa5d8e8a2575e72e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2c962de61fdce8eb657681123d55a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a5a2c962de61fdce8eb657681123d55a1">change_file_prop</a> )(void *file_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a5a2c962de61fdce8eb657681123d55a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of a file's property.  <a href="#a5a2c962de61fdce8eb657681123d55a1">More...</a><br /></td></tr>
<tr class="separator:a5a2c962de61fdce8eb657681123d55a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f84a4930f5c56d70fef7cde79aa16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#ad90f84a4930f5c56d70fef7cde79aa16">close_file</a> )(void *file_baton, const char *text_checksum, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:ad90f84a4930f5c56d70fef7cde79aa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are done processing a file, whose baton is <em>file_baton</em> (set by <code>add_file</code> or <code>open_file</code>).  <a href="#ad90f84a4930f5c56d70fef7cde79aa16">More...</a><br /></td></tr>
<tr class="separator:ad90f84a4930f5c56d70fef7cde79aa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e0d45dca3bada7441fa92b05e6390b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#aa4e0d45dca3bada7441fa92b05e6390b">absent_file</a> )(const char *path, void *parent_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:aa4e0d45dca3bada7441fa92b05e6390b"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the directory represented by <em>parent_baton</em>, indicate that <em>path</em> is present as a file in the edit source, but cannot be cannot be conveyed to the edit consumer.  <a href="#aa4e0d45dca3bada7441fa92b05e6390b">More...</a><br /></td></tr>
<tr class="separator:aa4e0d45dca3bada7441fa92b05e6390b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1136a14e1260c9c63545761bac06f2de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a1136a14e1260c9c63545761bac06f2de">close_edit</a> )(void *edit_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a1136a14e1260c9c63545761bac06f2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">All delta processing is done.  <a href="#a1136a14e1260c9c63545761bac06f2de">More...</a><br /></td></tr>
<tr class="separator:a1136a14e1260c9c63545761bac06f2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1200c7e8f04ef799a6eda09146311896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a1200c7e8f04ef799a6eda09146311896">abort_edit</a> )(void *edit_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a1200c7e8f04ef799a6eda09146311896"><td class="mdescLeft">&#160;</td><td class="mdescRight">The editor-driver has decided to bail out.  <a href="#a1200c7e8f04ef799a6eda09146311896">More...</a><br /></td></tr>
<tr class="separator:a1200c7e8f04ef799a6eda09146311896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168d29f50aadb716a4e3c15b57cf0245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsvn__error__t.html">svn_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsvn__delta__editor__t.html#a168d29f50aadb716a4e3c15b57cf0245">apply_textdelta_stream</a> )(const struct <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *editor, void *file_baton, const char *base_checksum, <a class="el" href="group__svn__delta__txt__delta.html#gaeeec6577587bff31dc63bb22ed65b90f">svn_txdelta_stream_open_func_t</a> open_func, void *open_baton, apr_pool_t *scratch_pool)</td></tr>
<tr class="memdesc:a168d29f50aadb716a4e3c15b57cf0245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a text delta stream, yielding the new revision of a file.  <a href="#a168d29f50aadb716a4e3c15b57cf0245">More...</a><br /></td></tr>
<tr class="separator:a168d29f50aadb716a4e3c15b57cf0245"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A structure full of callback functions the delta source will invoke as it produces the delta. </p>
<dl class="section note"><dt>Note</dt><dd>Don't try to allocate one of these yourself. Instead, always use <a class="el" href="group__svn__delta__tree__deltas.html#gab15253a8fcc50b7813844832016641a2" title="Return a default delta editor template, allocated in pool. ">svn_delta_default_editor()</a> or some other constructor, to avoid backwards compatibility problems if the structure is extended in future releases and to ensure that unused slots are filled in with no-op functions.</dd></dl>
<h3>Function Usage</h3>
<p>Here's how to use these functions to express a tree delta.</p>
<p>The delta consumer implements the callback functions described in this structure, and the delta producer invokes them. So the caller (producer) is pushing tree delta data at the callee (consumer).</p>
<p>At the start of traversal, the consumer provides <em>edit_baton</em>, a baton global to the entire delta edit. If there is a target revision that needs to be set for this operation, the producer should call the <code>set_target_revision</code> function at this point.</p>
<p>Next, if there are any tree deltas to express, the producer should pass the <em>edit_baton</em> to the <code>open_root</code> function, to get a baton representing root of the tree being edited.</p>
<p>Most of the callbacks work in the obvious way: </p><pre class="fragment">@c delete_entry
@c add_file
@c add_directory
@c open_file
@c open_directory
</pre><p>Each of these takes a directory baton, indicating the directory in which the change takes place, and a <em>path</em> argument, giving the path of the file, subdirectory, or directory entry to change.</p>
<p>The <em>path</em> argument to each of the callbacks is relative to the root of the edit. Editors will usually want to join this relative path with some base stored in the edit baton (e.g. a URL, or a location in the OS filesystem).</p>
<p>Since every call requires a parent directory baton, including <code>add_directory</code> and <code>open_directory</code>, where do we ever get our initial directory baton, to get things started? The <code>open_root</code> function returns a baton for the top directory of the change. In general, the producer needs to invoke the editor's <code>open_root</code> function before it can get anything of interest done.</p>
<p>While <code>open_root</code> provides a directory baton for the root of the tree being changed, the <code>add_directory</code> and <code>open_directory</code> callbacks provide batons for other directories. Like the callbacks above, they take a <em>parent_baton</em> and a relative path <em>path</em>, and then return a new baton for the subdirectory being created / modified &mdash; <em>child_baton</em>. The producer can then use <em>child_baton</em> to make further changes in that subdirectory.</p>
<p>So, if we already have subdirectories named `foo' and `foo/bar', then the producer can create a new file named `foo/bar/baz.c' by calling:</p>
<ul>
<li><code>open_root</code> () &mdash; yielding a baton <em>root</em> for the top directory</li>
<li><code>open_directory</code> (<em>root</em>, "foo") &mdash; yielding a baton <em>f</em> for `foo'</li>
<li><code>open_directory</code> (<em>f</em>, "foo/bar") &mdash; yielding a baton <em>b</em> for `foo/bar'</li>
<li><code>add_file</code> (<em>b</em>, "foo/bar/baz.c")</li>
</ul>
<p>When the producer is finished making changes to a directory, it should call <code>close_directory</code>. This lets the consumer do any necessary cleanup, and free the baton's storage.</p>
<p>The <code>add_file</code> and <code>open_file</code> callbacks each return a baton for the file being created or changed. This baton can then be passed to <code>apply_textdelta</code> or <code>apply_textdelta_stream</code> to change the file's contents, or <code>change_file_prop</code> to change the file's properties. When the producer is finished making changes to a file, it should call <code>close_file</code>, to let the consumer clean up and free the baton.</p>
<p>The <code>add_file</code> and <code>add_directory</code> functions each take arguments <em>copyfrom_path</em> and <em>copyfrom_revision</em>. If <em>copyfrom_path</em> is non-<code>NULL</code>, then <em>copyfrom_path</em> and <em>copyfrom_revision</em> indicate where the file or directory should be copied from (to create the file or directory being added). In that case, <em>copyfrom_path</em> must be either a path relative to the root of the edit, or a URI from the repository being edited. If <em>copyfrom_path</em> is <code>NULL</code>, then <em>copyfrom_revision</em> must be <a class="el" href="svn__types_8h.html#a8857d4630bf116eaba54a1b65d43ad92" title="The &#39;official&#39; invalid revision num. ">SVN_INVALID_REVNUM</a>; it is invalid to pass a mix of valid and invalid copyfrom arguments.</p>
<h3>Function Call Ordering</h3>
<p>There are six restrictions on the order in which the producer may use the batons:</p>
<ol type="1">
<li>The producer may call <code>open_directory</code>, <code>add_directory</code>, <code>open_file</code>, <code>add_file</code> at most once on any given directory entry. <code>delete_entry</code> may be called at most once on any given directory entry and may later be followed by <code>add_directory</code> or <code>add_file</code> on the same directory entry. <code>delete_entry</code> may not be called on any directory entry after <code>open_directory</code>, <code>add_directory</code>, <code>open_file</code> or <code>add_file</code> has been called on that directory entry.</li>
<li>The producer may not close a directory baton until it has closed all batons for its subdirectories.</li>
<li>When a producer calls <code>open_directory</code> or <code>add_directory</code>, it must specify the most recently opened of the currently open directory batons. Put another way, the producer cannot have two sibling directory batons open at the same time.</li>
<li>A producer must call <code>change_dir_prop</code> on a directory either before opening any of the directory's subdirs or after closing them, but not in the middle.</li>
<li><p class="startli">When the producer calls <code>open_file</code> or <code>add_file</code>, either:</p>
<p class="startli">(a) The producer must follow with any changes to the file (<code>change_file_prop</code> and/or <code>apply_textdelta</code> / <code>apply_textdelta_stream</code>, as applicable), followed by a <code>close_file</code> call, before issuing any other file or directory calls, or</p>
<p class="startli">(b) The producer must follow with a <code>change_file_prop</code> call if it is applicable, before issuing any other file or directory calls; later, after all directory batons including the root have been closed, the producer must issue <code>apply_textdelta</code> / <code>apply_textdelta_stream</code> and <code>close_file</code> calls.</p>
</li>
<li>When the producer calls <code>apply_textdelta</code>, it must make all of the window handler calls (including the <code>NULL</code> window at the end) before issuing any other <a class="el" href="structsvn__delta__editor__t.html" title="A structure full of callback functions the delta source will invoke as it produces the delta...">svn_delta_editor_t</a> calls.</li>
</ol>
<p>So, the producer needs to use directory and file batons as if it is doing a single depth-first traversal of the tree, with the exception that the producer may keep file batons open in order to make <code>apply_textdelta</code> / <code>apply_textdelta_stream</code> calls at the end.</p>
<h3>Pool Usage</h3>
<p>Many editor functions are invoked multiple times, in a sequence determined by the editor "driver". The driver is responsible for creating a pool for use on each iteration of the editor function, and clearing that pool between each iteration. The driver passes the appropriate pool on each function invocation.</p>
<p>Based on the requirement of calling the editor functions in a depth-first style, it is usually customary for the driver to similarly nest the pools. However, this is only a safety feature to ensure that pools associated with deeper items are always cleared when the top-level items are also cleared. The interface does not assume, nor require, any particular organization of the pools passed to these functions. In fact, if "postfix deltas" are used for files, the file pools definitely need to live outside the scope of their parent directories' pools.</p>
<p>Note that close_directory can be called <em>before</em> a file in that directory has been closed. That is, the directory's baton is closed before the file's baton. The implication is that <code>apply_textdelta</code> / <code>apply_textdelta_stream</code> and <code>close_file</code> should not refer to a parent directory baton UNLESS the editor has taken precautions to allocate it in a pool of the appropriate lifetime (the <em>dir_pool</em> passed to <code>open_directory</code> and <code>add_directory</code> definitely does not have the proper lifetime). In general, it is recommended to simply avoid keeping a parent directory baton in a file baton.</p>
<h3>Errors</h3>
<p>At least one implementation of the editor interface is asynchronous; an error from one operation may be detected some number of operations later. As a result, an editor driver must not assume that an error from an editing function resulted from the particular operation being detected. Moreover, once an editing function (including <code>close_edit</code>) returns an error, the edit is dead; the only further operation which may be called on the editor is <code>abort_edit</code>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00879">879</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a1200c7e8f04ef799a6eda09146311896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1200c7e8f04ef799a6eda09146311896">&#9670;&nbsp;</a></span>abort_edit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::abort_edit) (void *edit_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The editor-driver has decided to bail out. </p>
<p>Allow the editor to gracefully clean up things if it needs to.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01149">1149</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="aa426a6ce836356fd058e31ec942a26f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa426a6ce836356fd058e31ec942a26f5">&#9670;&nbsp;</a></span>absent_directory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::absent_directory) (const char *path, void *parent_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the directory represented by <em>parent_baton</em>, indicate that <em>path</em> is present as a subdirectory in the edit source, but cannot be conveyed to the edit consumer. </p>
<p>Currently, this would only occur because of authorization restrictions, but may change in the future.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01006">1006</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="aa4e0d45dca3bada7441fa92b05e6390b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e0d45dca3bada7441fa92b05e6390b">&#9670;&nbsp;</a></span>absent_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::absent_file) (const char *path, void *parent_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the directory represented by <em>parent_baton</em>, indicate that <em>path</em> is present as a file in the edit source, but cannot be cannot be conveyed to the edit consumer. </p>
<p>Currently, this would only occur because of authorization restrictions, but may change in the future.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01132">1132</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="ae9c63bef6b9de90802287a3c2697138d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c63bef6b9de90802287a3c2697138d">&#9670;&nbsp;</a></span>add_directory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::add_directory) (const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *result_pool, void **child_baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We are going to add a new subdirectory at <em>path</em>, a child of the directory represented by <em>parent_baton</em>. </p>
<p>We will use the value this callback stores in <em>*child_baton</em> as the parent baton for further changes in the new subdirectory.</p>
<p>If <em>copyfrom_path</em> is non-<code>NULL</code>, this add has history (i.e., is a copy), and the origin of the copy may be recorded as <em>copyfrom_path</em> under <em>copyfrom_revision</em>.</p>
<p>Allocations for the returned <em>child_baton</em> should be performed in <em>result_pool</em>. It is also typical to (possibly) save this pool for later usage by <code>close_directory</code>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00947">947</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="aa76e7e2f8a4ac090de385e08d96e3139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76e7e2f8a4ac090de385e08d96e3139">&#9670;&nbsp;</a></span>add_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::add_file) (const char *path, void *parent_baton, const char *copyfrom_path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> copyfrom_revision, apr_pool_t *result_pool, void **file_baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We are going to add a new file at <em>path</em>, a child of the directory represented by <em>parent_baton</em>. </p>
<p>The callback can store a baton for this new file in <em>**file_baton</em>; whatever value it stores there should be passed through to <code>apply_textdelta</code> or <code>apply_textdelta_stream</code>.</p>
<p>If <em>copyfrom_path</em> is non-<code>NULL</code>, this add has history (i.e., is a copy), and the origin of the copy may be recorded as <em>copyfrom_path</em> under <em>copyfrom_revision</em>.</p>
<p>Allocations for the returned <em>file_baton</em> should be performed in <em>result_pool</em>. It is also typical to save this pool for later usage by <code>apply_textdelta</code> and possibly <code>close_file</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Because the editor driver could be employing the "postfix
deltas" paradigm, <em>result_pool</em> could potentially be relatively long-lived. Every file baton created by the editor for a given editor drive might be resident in memory similtaneously. Editor implementations should ideally keep their file batons as conservative (memory-usage-wise) as possible, and use <em>result_pool</em> only for those batons. (Consider using a subpool of <em>result_pool</em> for scratch work, destroying the subpool before exiting this function's implementation.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01034">1034</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a05fe224723d88caa5d8e8a2575e72e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe224723d88caa5d8e8a2575e72e04">&#9670;&nbsp;</a></span>apply_textdelta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::apply_textdelta) (void *file_baton, const char *base_checksum, apr_pool_t *result_pool, <a class="el" href="group__svn__delta__txt__delta.html#ga4ca253c7fddd39261d28e76ba9c959f4">svn_txdelta_window_handler_t</a> *handler, void **handler_baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a text delta, yielding the new revision of a file. </p>
<p><em>file_baton</em> indicates the file we're creating or updating, and the ancestor file on which it is based; it is the baton set by some prior <code>add_file</code> or <code>open_file</code> callback.</p>
<p>The callback should set <em>*handler</em> to a text delta window handler; we will then call <em>*handler</em> on successive text delta windows as we receive them. The callback should set <em>*handler_baton</em> to the value we should pass as the <em>baton</em> argument to <em>*handler</em>. These values should be allocated within <em>result_pool</em>.</p>
<p><em>base_checksum</em> is the hex MD5 digest for the base text against which the delta is being applied; it is ignored if NULL, and may be ignored even if not NULL. If it is not ignored, it must match the checksum of the base text against which svndiff data is being applied; if it does not, <code>apply_textdelta</code> or the <em>*handler</em> call which detects the mismatch will return the error SVN_ERR_CHECKSUM_MISMATCH (if there is no base text, there may still be an error if <em>base_checksum</em> is neither NULL nor the hex MD5 checksum of the empty string). </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01085">1085</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a168d29f50aadb716a4e3c15b57cf0245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168d29f50aadb716a4e3c15b57cf0245">&#9670;&nbsp;</a></span>apply_textdelta_stream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::apply_textdelta_stream) (const struct <a class="el" href="structsvn__delta__editor__t.html">svn_delta_editor_t</a> *editor, void *file_baton, const char *base_checksum, <a class="el" href="group__svn__delta__txt__delta.html#gaeeec6577587bff31dc63bb22ed65b90f">svn_txdelta_stream_open_func_t</a> open_func, void *open_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a text delta stream, yielding the new revision of a file. </p>
<p>This callback operates on the passed-in <em>editor</em> instance.</p>
<p><em>file_baton</em> indicates the file we're creating or updating, and the ancestor file on which it is based; it is the baton set by some prior <code>add_file</code> or <code>open_file</code> callback.</p>
<p><em>open_func</em> is a function that opens a <a class="el" href="group__svn__delta__txt__delta.html#gaf599af000e3c3b976c17fd4e101ff7cf" title="A delta stream â€” this is the hat from which we pull a series of svn_txdelta_window_t objects...">svn_txdelta_stream_t</a> object. <em>open_baton</em> is provided by the caller.</p>
<p><em>base_checksum</em> is the hex MD5 digest for the base text against which the delta is being applied; it is ignored if NULL, and may be ignored even if not NULL. If it is not ignored, it must match the checksum of the base text against which svndiff data is being applied; if it does not, <code>apply_textdelta_stream</code> call which detects the mismatch will return the error <a class="el" href="svn__error__codes_8h.html#ac8784565366c15a28d456c4997963660ae0b4dcc1b314982153e251724ce8d40b" title="&quot;A checksum mismatch occurred&quot; ">SVN_ERR_CHECKSUM_MISMATCH</a> (if there is no base text, there may still be an error if <em>base_checksum</em> is neither NULL nor the hex MD5 checksum of the empty string).</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.10. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01176">1176</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a197108c566d919c1c7528e213f983f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197108c566d919c1c7528e213f983f95">&#9670;&nbsp;</a></span>change_dir_prop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::change_dir_prop) (void *dir_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of a directory's property. </p>
<ul>
<li><em>dir_baton</em> specifies the directory whose property should change.</li>
<li><em>name</em> is the name of the property to change.</li>
<li><em>value</em> is the new (final) value of the property, or <code>NULL</code> if the property should be removed altogether.</li>
</ul>
<p>The callback is guaranteed to be called exactly once for each property whose value differs between the start and the end of the edit.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00982">982</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a5a2c962de61fdce8eb657681123d55a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2c962de61fdce8eb657681123d55a1">&#9670;&nbsp;</a></span>change_file_prop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::change_file_prop) (void *file_baton, const char *name, const <a class="el" href="structsvn__string__t.html">svn_string_t</a> *value, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of a file's property. </p>
<ul>
<li><em>file_baton</em> specifies the file whose property should change.</li>
<li><em>name</em> is the name of the property to change.</li>
<li><em>value</em> is the new (final) value of the property, or <code>NULL</code> if the property should be removed altogether.</li>
</ul>
<p>The callback is guaranteed to be called exactly once for each property whose value differs between the start and the end of the edit.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01102">1102</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="ad10ab4a3452a9d3cbcb852392c87238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10ab4a3452a9d3cbcb852392c87238b">&#9670;&nbsp;</a></span>close_directory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::close_directory) (void *dir_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We are done processing a subdirectory, whose baton is <em>dir_baton</em> (set by <code>add_directory</code> or <code>open_directory</code>). </p>
<p>We won't be using the baton any more, so whatever resources it refers to may now be freed.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00994">994</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a1136a14e1260c9c63545761bac06f2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1136a14e1260c9c63545761bac06f2de">&#9670;&nbsp;</a></span>close_edit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::close_edit) (void *edit_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All delta processing is done. </p>
<p>Call this, with the <em>edit_baton</em> for the entire edit.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01141">1141</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="ad90f84a4930f5c56d70fef7cde79aa16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90f84a4930f5c56d70fef7cde79aa16">&#9670;&nbsp;</a></span>close_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::close_file) (void *file_baton, const char *text_checksum, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We are done processing a file, whose baton is <em>file_baton</em> (set by <code>add_file</code> or <code>open_file</code>). </p>
<p>We won't be using the baton any more, so whatever resources it refers to may now be freed.</p>
<p><em>text_checksum</em> is the hex MD5 digest for the fulltext that resulted from a delta application, see <code>apply_textdelta</code> and <code>apply_textdelta_stream</code>. The checksum is ignored if NULL. If not null, it is compared to the checksum of the new fulltext, and the error SVN_ERR_CHECKSUM_MISMATCH is returned if they do not match. If there is no new fulltext, <em>text_checksum</em> is ignored.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01120">1120</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a2cac42610758f4b2c20f4e37ae613db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cac42610758f4b2c20f4e37ae613db4">&#9670;&nbsp;</a></span>delete_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::delete_entry) (const char *path, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> revision, void *parent_baton, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the directory entry at <em>path</em>, a child of the directory represented by <em>parent_baton</em>. </p>
<p>If <em>revision</em> is a valid revision number, it is used as a sanity check to ensure that you are really removing the revision of <em>path</em> that you think you are.</p>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>revision</em> parameter is typically used only for client-&gt;server commit-type operations, allowing the server to verify that it is deleting what the client thinks it should be deleting. It only really makes sense in the opposite direction (during server-&gt;client update-type operations) when the trees whose delta is being described are ancestrally related (that is, one tree is an ancestor of the other). </dd></dl>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00928">928</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a4e4b50102b318e593e206b18a95584e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4b50102b318e593e206b18a95584e5">&#9670;&nbsp;</a></span>open_directory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::open_directory) (const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *result_pool, void **child_baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We are going to make changes in the subdirectory at <em>path</em>, a child of the directory represented by <em>parent_baton</em>. </p>
<p>The callback must store a value in <em>*child_baton</em> that should be used as the parent baton for subsequent changes in this subdirectory. If a valid revnum, <em>base_revision</em> is the current revision of the subdirectory.</p>
<p>Allocations for the returned <em>child_baton</em> should be performed in <em>result_pool</em>. It is also typical to (possibly) save this pool for later usage by <code>close_directory</code>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00965">965</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a00452a0fc66e4f65244ce74d2af8d6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00452a0fc66e4f65244ce74d2af8d6b8">&#9670;&nbsp;</a></span>open_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::open_file) (const char *path, void *parent_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *result_pool, void **file_baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We are going to make changes to a file at <em>path</em>, a child of the directory represented by <em>parent_baton</em>. </p>
<p>The callback can store a baton for this new file in <em>**file_baton</em>; whatever value it stores there should be passed through to <code>apply_textdelta</code> or <code>apply_textdelta_stream</code>. If a valid revnum, <em>base_revision</em> is the current revision of the file.</p>
<p>Allocations for the returned <em>file_baton</em> should be performed in <em>result_pool</em>. It is also typical to save this pool for later usage by <code>apply_textdelta</code> and possibly <code>close_file</code>.</p>
<dl class="section note"><dt>Note</dt><dd>See note about memory usage on <em>add_file</em>, which also applies here. </dd></dl>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l01056">1056</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="afc7fa0f1296811edaa3808a1cb630a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7fa0f1296811edaa3808a1cb630a45">&#9670;&nbsp;</a></span>open_root</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::open_root) (void *edit_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> base_revision, apr_pool_t *result_pool, void **root_baton)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>*root_baton</em> to a baton for the top directory of the change. </p>
<p>(This is the top of the subtree being changed, not necessarily the root of the filesystem.) As with any other directory baton, the producer should call <code>close_directory</code> on <em>root_baton</em> when done. And as with other <code>open_*</code> calls, the <em>base_revision</em> here is the current revision of the directory (before getting bumped up to the new target revision set with <code>set_target_revision</code>).</p>
<p>Allocations for the returned <em>root_baton</em> should be performed in <em>result_pool</em>. It is also typical to (possibly) save this pool for later usage by <code>close_directory</code>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00907">907</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<a id="a34125322c4f485687f0b0a2ccaea84db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34125322c4f485687f0b0a2ccaea84db">&#9670;&nbsp;</a></span>set_target_revision</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsvn__error__t.html">svn_error_t</a>*(* svn_delta_editor_t::set_target_revision) (void *edit_baton, <a class="el" href="svn__types_8h.html#af16427ed53d30f27da225c56552d2a89">svn_revnum_t</a> target_revision, apr_pool_t *scratch_pool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target revision for this edit to <em>target_revision</em>. </p>
<p>This call, if used, should precede all other editor calls.</p>
<dl class="section note"><dt>Note</dt><dd>This is typically used only for server-&gt;client update-type operations. It doesn't really make much sense for commit-type operations, because the revision of a commit isn't known until the commit is finalized.</dd></dl>
<p>Any temporary allocations may be performed in <em>scratch_pool</em>. </p>

<p class="definition">Definition at line <a class="el" href="svn__delta_8h_source.html#l00891">891</a> of file <a class="el" href="svn__delta_8h_source.html">svn_delta.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="svn__delta_8h_source.html">svn_delta.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
